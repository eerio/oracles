Hey\!

I apologize for taking so long to get back \- just after we had spoken, I stumbled across a book by Steven Cook and Phuong Nguyen \[1\] which answers the questions I had been trying to solve (and even pose) for the past two years\!

The main question of my Master’s thesis is: how complicated does a programming language have to be, and how to design it, so that we can implement a program X in it? What is the simplest programming language expressing precisely the functions from a complexity class C? Cook and Nguyen spent decades designing their theory in the area of bounded arithmetic (or bounded reverse mathematics) and I think it is detailed and practical enough to provide a basis for a new proof assistant (not based on type theory\!). They introduce logical theories VC, corresponding to complexity classes C, such that if a theorem is provable in VC, the induction hypotheses needed in the proof can be formulated using concepts from C. I believe this work is important, as it would probably enable us to formalize simple theorems (and concepts from daily programming practice\!) in a very straightforward way, not requiring any complicated tool such as Coq, HOL or Mizar\! There are also reasons to believe that code extraction from such a system would be feasible, as “Witnessing theorems” are proved in this book for some of their logics. But this aspect is logically subtle; the proofs as-is don’t seem to be computationally feasible ([https://mathoverflow.net/q/492469/561687](https://mathoverflow.net/q/492469/561687)) 

I spent some time trying to formalize their results in Isabelle/Pure and in Lean, but my lack of logical expertise really limits me. I spoke to a good couple of people in Warsaw trying to get their attention, but it’s really difficult for me to convince anyone that it makes sense to take on this project, as it requires some intuition on both logic and formal verification. If you would like to hear more about it and why I believe it is interesting and super impactful, please let me know and I will try to sell this idea to you :) Also, if you have the intuitions, or work with someone who has them, on the practicality of theorems in logic and reverse maths, please let me know \- I will be more than happy to consult what would be the best direction to formalize their results.

I have also come up with a few projects I think could be impactful in automated reasoning. These are alternatives to the ongoing projects in Prague we spoke about last time. I will be happy to help you with your projects, but am also curious if we could find some common ground on the ideas below:

1) In Prague, you hold the SAT Solving competition. I think this is really cool, as SAT solvers show that it is possible and practical to solve problems which don’t seem computationally feasible.   
   1) ‘tauto’ for weaker logics: I think it would be interesting to take a logic for which the problem of checking if a formula is a tautology is in NP, embed it in Coq or Lean and create tactic ‘weaktauto’, hammering this logic using a SAT solver, similarly to ‘tauto’ from Coq / ‘itauto’ from Lean, which solves more (is in PSPACE).  
   2) A demonstration of the power of these tactics (including ‘tauto’\!) would be to reduce e.g. Hamilton cycle problem to tautology problem in this logic, hammer the instance with the tactic (so, construct the intuitionistic proof or fail), and parse out the answer to Hamilton cycle from the proof. I have already implemented it partially, reducing Hamilton to IIPL tautology, running ‘itauto’ tactic and extracting the cycle from the actual proof created by ‘itauto’. But I wasn’t able to test it very thoroughly, as the ‘itauto’ stackoverflowed for n=3 (the formula had \~100 clauses for this size). For weaker logics (e.g. logic with tauto problem in NP), we could perhaps implement the tactic using a sat-solver.  
   3) ‘tauto’ tactics are not designed to handle large instances. I think it would be interesting to show how powerful these tactics are, and how Coq can be used as a strong calculator, by showing a reduction from Sokoban to IIPL tautology problem, hammering it with tauto and drawing graphically (as an animation\!) the Sokoban solution extracted from the intuitionistic proof. This would require us to have something stronger than a SAT-solver, perhaps a  QBNF solver. We can’t really do it readily, as ‘itauto’ quickly stackoverflows, and ‘tauto’ is slow.   
   4) going down, maybe it would make good sense to consider solvers weaker than SAT solvers; Horn-Sat solvers?  
   5) if we were to implement the new theorem prover based on Cook and Nguyen: the theories they introduce are all based on a simple characterization of AC0 functions \+ a problem complete for class C. Having a programming language expressing AC0 and a fast solver for HornSAT gives us a language for functions in P, 2SAT gives us NL etc. This would create a bigger need for super fast programs for well-known complete problems, including probably HornSAT, but also for their verification. They would probably need to be formalized in Dafny or in Why3. I found a good implementation of imperative Topological sort in dafny, which is a good step for formalization of a Circuit Value Problem solver.  
   6) even in NP, the P reductions used might have a quadratic blowup in instance size \- maybe it makes sense to consider solvers for other NP-hard problems besides SAT?  
2) I believe that the results from Descriptive Complexity, of the form ‘FO\[TC\] \= NL’, have practical importance: if we were to design a system allowing us to write imperative programs (at most NL-hard), we are totally fine if our type system / proof system is limited to FO\[TC\]. We don’t need to have a stronger logic, as every specification of an NL program can be stated in FO\[TC\]. I think that FO\[TC\] is pretty high already? But for lower complexities, maybe we could quickly design a system similar to Dafny, allowing us to write imperative programs, and verify them in a logic whose expressive power is well studied\! (it would also increase the importance of SAT / other solvers, as Dafny uses SAT solvers to verify pre- and post- conditions)  
3) I enjoy Dafny as a system. I think this tool is already enough to formalize results from complexity theory and I would be down to try doing it; I would like the main objective of this work to be popularization of imperative programs verification among complexity theorists, which have an insanely hard time formalizing their results in Coq sometimes. I just slightly worry that Dafny doesn’t scale well.

\[1\] \-  The pre-print is available here: [https://www.karlin.mff.cuni.cz/\~krajicek/cook-nguyen.pdf](https://www.karlin.mff.cuni.cz/~krajicek/cook-nguyen.pdf) My university doesn’t give me access to the version at the Cambridge publisher site, but my friend from Oxford sent me the PDFs of separate chapters which I glued together and applied OCR onto. I will be happy to send it to you if your institution also doesn’t have this access.