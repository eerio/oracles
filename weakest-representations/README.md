- Digression: why do we assume that proofs have a tree structure?
> Cirquent calculus is a proof calculus that manipulates graph-style constructs termed cirquents, as opposed to the traditional tree-style objects such as formulas or sequents.

- what is the weakest representation of solvable Sudoku?

- Digression:
> conversion of MSO to NFA is non-elementary, but NFA to MSO is linear-time  
> what are the best data representations?  
> what about languages over the unary alphabet?  
> are there np-hard languages over the unary alphabet?  
> can the only data type in the language be {1^n: n in Nat}?  
> it seems natural that the data type for computers is { {0,1}^n: n in Nat},  
> but for set-theory based mathematics, it's Set = Empty | {Set},  
> where {} stands for... a set. So like a list, but with no order and no duplicates

- Digression:
> Second-order logic is hard, because it requires processing very complicated sets. Maybe it'd be easier if these complicated sets were given by their "generators"?

- Digression:
> when data on input is in a convenient form, a reduction is in L, but if it the input is just represented as a natural number (because every countable sequence can be numbered), no efficient algorithm exists (try proving that the algorithm would probably have to 'unpack' the structure, i.e. construct the actual structure, which it is unable to because of the memory limit)

- Homotopy Type Theory should eat itself (but so far, it’s too big to swallow); related to the limitations of the expressibility of the metalanguage:
> https://homotopytypetheory.org/2014/03/03/hott-should-eat-itself/

jak silna jest potrzebna logika by stwierdzić spójność / sprzeczność zestawu aksjomatów?
czy syntax musi być drzewem?
teoria typów metajęzyka
najsłabszy syntax, który wyrazi wszystkie poprawne programy innego języka
taki syntax jest w stanie rozwiązać problem HALT dla rozważanego języka!!
szukamy takiego metajęzyka, żeby problem stopu podjęzyka był łatwy.

10. czemu chcemy koniecznie żeby syntax był CFG? 

